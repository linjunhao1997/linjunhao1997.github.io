<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="面向对象把某件东西抽象成对象，定义对象属性，定义方法等，赋予调用属性和方法的权限，其他对象只能在权限下改变获取或改变对象的状态  特性 抽象：忽略细节，更注重通用的方面 抽象类和接口 抽象类可以继承实体类，前提是实体类有继承权限的构造器   抽象类可以声明对象，不能实例化，可以有构造函数   抽象类中可以有静态方法，接口中也可以有   接口可以继承多个接口   接口只能被public、abstra">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="http://yoursite.com/2018/10/18/Java基础/index.html">
<meta property="og:site_name" content="驿站">
<meta property="og:description" content="面向对象把某件东西抽象成对象，定义对象属性，定义方法等，赋予调用属性和方法的权限，其他对象只能在权限下改变获取或改变对象的状态  特性 抽象：忽略细节，更注重通用的方面 抽象类和接口 抽象类可以继承实体类，前提是实体类有继承权限的构造器   抽象类可以声明对象，不能实例化，可以有构造函数   抽象类中可以有静态方法，接口中也可以有   接口可以继承多个接口   接口只能被public、abstra">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-10-17T18:53:15.157Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java基础">
<meta name="twitter:description" content="面向对象把某件东西抽象成对象，定义对象属性，定义方法等，赋予调用属性和方法的权限，其他对象只能在权限下改变获取或改变对象的状态  特性 抽象：忽略细节，更注重通用的方面 抽象类和接口 抽象类可以继承实体类，前提是实体类有继承权限的构造器   抽象类可以声明对象，不能实例化，可以有构造函数   抽象类中可以有静态方法，接口中也可以有   接口可以继承多个接口   接口只能被public、abstra">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/18/Java基础/"/>





  <title>Java基础 | 驿站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6f502c419cf100aac28bd9cae568a13c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">驿站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/18/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林俊浩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驿站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-18T02:38:13+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/18/Java基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/18/Java基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>把某件东西抽象成对象，定义对象属性，定义方法等，赋予调用属性和方法的权限，其他对象只能在权限下改变获取或改变对象的状态</p>
<ul>
<li><strong>特性</strong><ul>
<li><strong>抽象</strong>：忽略细节，更注重通用的方面<ul>
<li><strong>抽象类和接口</strong><ul>
<li>抽象类可以继承实体类，前提是实体类有继承权限的构造器  </li>
<li>抽象类可以声明对象，不能实例化，可以有构造函数  </li>
<li>抽象类中可以有静态方法，接口中也可以有  </li>
<li>接口可以继承多个接口  </li>
<li>接口只能被public、abstract修饰，接口中的方法的默认public abstract修饰，JDK8以后可以用defualt修饰 </li>
<li>接口中定义的常量默认为 public static final修饰</li>
</ul>
</li>
</ul>
</li>
<li><strong>继承</strong>：子类可以使用父类的成员变量和方法，提高代码复用性<ul>
<li><strong>和组合的区别</strong><ul>
<li>继承是is - a的关系，能更好实现多态，过多使用继承代码的可维护性差</li>
<li>组合是在新类创建已有类对象复用已有类的功能，是has -a的关系，组合有更高的拓展性</li>
</ul>
</li>
</ul>
</li>
<li><strong>多态</strong>：同样的方法作用于不同对象会有不同结果<ul>
<li><strong>方法重载和方法重写</strong><ul>
<li>重载是一个编译时多态，不同的参数个数、参数类型、参数顺序</li>
<li>重写是运行时多态，调用的具体方法是动态绑定的</li>
<li>如果重载方法的参数与父类方法的参数为父子关系，优先选择子类。但不能有歧意，编译器会报错</li>
</ul>
</li>
</ul>
</li>
<li><strong>封装</strong>：对象的属性和实现方法对外隐藏，通过访问修饰符调整封装的级别</li>
</ul>
</li>
<li><strong>6原则1法则</strong><ul>
<li>单一职责原则：一个类只做它该做的事</li>
<li>开闭原则：代码易于拓展就是对拓展开发，代码不应该被修改，对修改关闭</li>
<li>依赖倒置原则：设计要依赖于抽象，面向接口编程</li>
<li>里氏替换原则：任何时候子类都可以替换掉父类</li>
<li>接口隔离原则：接口单一职责，细粒化</li>
<li>组合原则：优先使用组合复用代码</li>
<li>迪米特法则：一个对象对其他对象尽可能少的了解<h2 id="关键字和基本概念"><a href="#关键字和基本概念" class="headerlink" title="关键字和基本概念"></a>关键字和基本概念</h2></li>
</ul>
</li>
<li><strong>语法</strong><ul>
<li>continue跳出本次循环继续下次循环</li>
<li>break跳出当前循环，可跳出多重循环,跳出switch否则执行后面的case语句</li>
<li>switch表达式只能是byte, short, char, int和枚举类型，JDK7开始可以是String</li>
</ul>
</li>
<li><strong>内部类</strong>：内部类相当于外部类的一个成员变量，可以直接访问外部变量；但是外部类不能直接访问内部类变量，必须通过创建内部类实例建立联系后再访问（内外之间的访问是不关乎权限的）  <ul>
<li><strong>静态内部类</strong>：只能访问外部类的静态成员和静态方法，不依赖外部类实例而实例化</li>
<li><strong>普通内部类</strong>：能访问外部类的成员和方法，无论是否静态，但是本身不能有静态成员和静态方法，<br>  依赖外部类实例而实例化</li>
</ul>
</li>
<li><strong>构造函数</strong><ul>
<li>构造函数不能被继承和重写，可重载</li>
<li>编译器在运行子类构造函数前必须先执行父类的构造函数</li>
<li>子类构造函数中的第一行必须调用父类构造函数, 若父类只要无参构造函数，则子类构造函数可以省略这一行</li>
<li>若父类有有参的构造函数，则必须在这一行通过super显示调用父类的构造函数</li>
</ul>
</li>
<li><strong>super</strong><ul>
<li>子类重写父类方法后，通过super仍可调用父类方法</li>
</ul>
</li>
<li><strong>final</strong><ul>
<li>final变量是无法修改的，无默认值，要先赋值或者在构造方法中初始化,</li>
<li>final static表示常量，常量必须在定义时赋值</li>
<li>只有final能修饰形参，表示这个参数不能重新赋值，否则编译错误</li>
</ul>
</li>
<li><strong>静态方法和静态变量</strong><ul>
<li>类成员必须是静态的，非静态成员和非静态方法是实例成员和实例方法</li>
<li>静态方法只能访问静态变量， 普通方法既可访问静态也可访问非静态</li>
<li>静态方法是不能重写的，实际上父类和子类相同的静态方法是两个独立的方法，调用哪个方法取决于声明的类型</li>
</ul>
</li>
<li><strong>类加载顺序</strong><ul>
<li>static变量和static块的初始化顺序与代码顺序有关，哪个在前哪个先初始化</li>
<li>反编译发现构造代码块是在调用构造函数时插入到构造函数里的，位于super后(如果有)，所以是成员变量 &gt; 构造代码块 &gt; 构造函数</li>
<li>总的顺序是：父类static &gt; 子类static &gt; 父类成员 &gt; 父类构造块 &gt; 父类构造函数 &gt; 子类成员 &gt; 子类构造块 &gt; 子类构造函数<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>Java小数默认为double</li>
<li>整型根据前缀表示不同进制，16进制(0x或0X)，8进制(0),Java7开始可以写2进制(0b或0B)</li>
<li>低精度到高精度：byte&lt;short&lt;char&lt;int&lt;long&lt;float&lt;double,向下转型要强制转换，精度会损失，”+=”赋值隐含强制转换</li>
<li>char不管英文还是中文，固定占用占用2个字节，用来储存Unicode字符，所以也包括了中文；<br>C/C++中由于采用的字符编码集是ASCII，只有一个字节，因此没办法表示一个中文字符</li>
<li>不同数据类型运算时会自动向上(高精度)转型，final修饰除外</li>
<li>boolean不可以和其他基本数据类型相互转换</li>
<li>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，<br>如果其中一个操作数是float类型，另一个将会转换为float类型。否则，<br>如果其中一个操作数是long类型，另一个会转换为long类型。否则，<br>两个操作数都转换为int类型(byte，short，char进行计算时都会提升为int类型)<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2></li>
<li>&amp;有两种用法：按位与和逻辑与。无论左边运算true或false，右边也会运算，|同理</li>
<li>&amp;&amp;是短路与，左边运算结果位true,右边才会运算，||同理</li>
<li><strong>移位运算符</strong> ：按二进制形式把所有的数字移动位数，计算机使用补码表示和存储</li>
</ul>
</li>
<li><strong>&lt;&lt;</strong> : 左移，高位舍弃，低位空位补0</li>
<li><strong>&gt;&gt;</strong> : 右移，低位舍弃，高位空位补符号位（正数补0，负数补1）</li>
<li><strong>&gt;&gt;&gt;</strong> : 无符号右移，忽略符号位，空位补0<h2 id="常见包、类、接口"><a href="#常见包、类、接口" class="headerlink" title="常见包、类、接口"></a>常见包、类、接口</h2><ul>
<li><strong>包</strong>：java.lang, java.io, java.util, java.net, java.sql</li>
<li><strong>类</strong>：String, Thread, ArrayList, InputStream/OutputStream, Math</li>
<li><strong>接口</strong>：List, Map, Iterator, Runnable, Serializable<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2></li>
</ul>
</li>
</ul>
</li>
<li><strong>层次</strong>：Error和Exception继承Throwable，RuntimeException继承Exception</li>
<li><strong>类型</strong>：RuntimeException及其子类是非受检异常；除此之外Exception是受检异常</li>
<li><strong>处理</strong>：Error捕获不到，RuntimeException不要求捕获，Exception要求抛出或捕获</li>
<li><strong>常见的RuntimeException</strong>：NullPointerException, ClassCastException, IllegalArgumentExeption, IndexOutOfBoundsException</li>
<li><strong>异常语句</strong>：finally中的return语句会覆盖前面的return语句； 如果一个方法出现异常那么只运行catch和finally中的代码，其他代码忽略</li>
<li><strong>throw和throws</strong>：throw用于抛出异常，throws用于在方法中声明会出现的异常<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2></li>
<li><strong>List</strong><ul>
<li><strong>ArrayList</strong><ul>
<li>默认容量为10，默认增长0.5倍+1</li>
</ul>
</li>
<li><strong>CopyOnWriterArrayList</strong><ul>
<li>适用于读多写少的并发环境，写时对原对象拷贝进行修改操作，修改完成后再把拷贝赋给原对象</li>
<li>写的操作过于消耗资源，绝对线程安全，但是只能保证数据的最终一致性，不能保证实时一致性</li>
<li>Conllections.SynchronizedList写的性能好，读的性能差</li>
</ul>
</li>
<li><strong>LinkedList</strong><ul>
<li>任何位置都能高效插入和删除的双向链表</li>
</ul>
</li>
<li><strong>Vector</strong><ul>
<li>默认容量10，默认增长1倍，加了锁机制</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><strong>HashMap</strong><ul>
<li>JDK7：数组 + 链表实现，数组元素比作一个bucket, 每个bucket由一个Entry&lt;K,V&gt;链表组成，<br>如果K的hashcode冲突会放在相同的bucket， hash冲突严重时，链表会越来越长，时间复杂度为O(n),<br>当超过设置的装填因子会重rehash，容量扩容1倍</li>
<li>JDK8：超过装填因子时，链表转换成红黑树的结构</li>
<li>不允许键重复，对应的类要重写hashcode和equals</li>
<li>装填因子 = 元素个数 / 容量，默认容量16，装填因子大于0.75就扩容1倍</li>
<li>元素越多越容易冲突，新能降低，用拉链法解决冲突</li>
<li>支持一个null键，支持null值</li>
<li>并发环境put会出现死循环，因为扩容问题？</li>
</ul>
</li>
<li><strong>WeakHashMap</strong><ul>
<li>用于存弱引用的键值对，会被GC回收保存到ReferenceQueue，下次操作map时，同步map和queue中的对象，<br>删除被回收的键值对</li>
</ul>
</li>
<li><strong>TreeMap</strong><ul>
<li>通过键值的排序规则排序</li>
</ul>
</li>
<li><strong>LinkedHashMap</strong><ul>
<li>HashMap+LinkedList实现，用双向链表的形式把Entry&lt;K,V&gt;连接起来，保证元素的迭代顺序和跟插入顺序相同</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>加了锁机制，不可插入null键和null值，回报空指针异常(源码规定)</li>
<li>子类Properties用于读取.properties文件</li>
</ul>
</li>
<li><strong>Conllection.SynchronizedMap</strong><ul>
<li>HashTable的锁是方法级别，而它的锁是代码块级别, 可以插入null键和null值</li>
</ul>
</li>
<li><strong>ConcurrentHashMap</strong><ul>
<li>采用分段锁实现，JDK8以后采用CAS实现</li>
<li>适用于并发读写的场景，提高吞吐量，迭代时是弱一致性的</li>
</ul>
</li>
</ul>
</li>
<li><strong>Set</strong><ul>
<li><strong>HashSet</strong><ul>
<li>是HashMap的keySet，基本和Map类似</li>
</ul>
</li>
<li><strong>TreeSet</strong><ul>
<li>与TreeMap类似</li>
</ul>
</li>
</ul>
</li>
<li><strong>错误检测机制</strong><ul>
<li><strong>fail-fast</strong>: 迭代器有个变量expectedModCount保存着集合的modCount变量值，<br>modCount值记录着集合的修改次数，每次next和remove都会检查这两个值是否相等，<br>如果不相等则抛出ConcurrentModifiedException,java.util包下的集合类都是快速失败的  </li>
<li><strong>fail-safe</strong>: 迭代器对集合的拷贝进行遍历，集合被修改对遍历无影响，java.util.concurrent包下<br>的集合都是安全失败的</li>
</ul>
</li>
<li><strong>Iterator</strong><ul>
<li>支持从集合中安全删除对象，在迭代时只能针对迭代器操作，如果在迭代时直接对集合修改，<br>会抛出ConcurrentModifiedException</li>
<li>foreach语句内部使用Iterator实现</li>
</ul>
</li>
<li><strong>集合数组转换</strong><ul>
<li>集合转数组 toArray(T[] a)</li>
<li>数组转集合 Arrays.asList() 实质上仍是数组，只是通过适配实现转换，不能用操作集合的方法对转换后的集合操作<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2>运行状态下能获取类的信息，能调用任意对象的方法和属性，但破坏了封装程序；更加灵活，但性能低</li>
</ul>
</li>
<li><strong>得到Class对象的方式</strong>：object.getClass(), object.class, Class.forName(String classname)</li>
<li><strong>Class.forName()和ClassLoader.loadClass()</strong><br>Class.forName()内部实际调用的方法是Class.forName(className,true,classloader),true表示加载class文件到JVM并初始化类；ClassLoader.loadClass(className)方法内部实际调用的方法是ClassLoader.loadClass(className,false)，false表示不链接,意味着不会进行类初始化  <h2 id="方法解惑"><a href="#方法解惑" class="headerlink" title="方法解惑"></a>方法解惑</h2></li>
<li><strong>数组拷贝效率</strong>： System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环拷贝</li>
<li><strong>hashCode()</strong> ：默认返回对象的内存地址</li>
<li><strong>equals()</strong> ：在Object中是比较对象内存地址的，相当于”=”,在String中被重写了，比较的是字符串值</li>
<li><strong>Integer.valueOf()和new Integer()</strong> ：Integer.valueOf会先查看缓存是否有实例，如果在-128 ~ 127范围内没找到缓存中的实例，则创建实例，<br>  new Integer()则直接创建实例</li>
<li><strong>Math.round()/floor()/ceil()</strong> ：注意float型是转成int型，double型转成long型<ul>
<li><strong>round</strong> : 加上0.5向下取整</li>
<li><strong>floor</strong> ：向下取整，取数轴上比参数小的整数</li>
<li><strong>ceil</strong> : 向上取整，取数轴上比参数大的整数 <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2>线程是运行在一个单一进程上下文中的逻辑流，通俗点讲就是：线程是进程内部的执行序列</li>
</ul>
</li>
<li><strong>并发和并行</strong><br>并发是一个时刻多个任务的运行，宏观并行，微观串行；并行是同个时间上多个任务的运行，通常需要多核CPU才能实现</li>
<li><strong>线程安全</strong><br>通过分析并发下是否满足三大性质能实现线程安全<ul>
<li><strong>Java内存模型(JMM)</strong><br>分为主内存和工作内存。主内存存储共享的变量；每个线程都有自己的工作内存，存储线程本地变量和需要共享变量<br>变量的拷贝副本，每次修改拷贝时都会更新主内存的值</li>
<li><strong>volatile</strong><ul>
<li>volatile关键字保证变量被修改后，变量的值对其他线程是立即可见的（新的变量值立马写会主内存，保证可见性）  </li>
<li>对于变量非原子性的操作（例如：变量自增）是不能保证原子性的</li>
<li>volatile能只能限制变量前后之间代码的重排序，但不能保证volatile之前和之后代码的重排序，能保证一定的有序性</li>
</ul>
</li>
<li><strong>三大性质</strong><ul>
<li><strong>原子性</strong><ul>
<li><strong>竞态条件</strong>：多个线程同时竞争/更新共享的资源是会产生竞态条件，通过同步保证原子性</li>
<li><strong>临界区</strong>：导致竞态条件的代码区</li>
<li><strong>复合操作</strong>: 一组以原子性的操作确保线程安全，如自增就是非原子性操作，但是用atomic变量自增就可满足原子性操作</li>
</ul>
</li>
<li><strong>可见性</strong><br>执行读操作的线程能立马看到其他线程写入的值</li>
<li><strong>有序性</strong><br>Java内存模型运行编译器和处理器对指令重排序，对单线程无影响，但会影响多线程并发执行的正确性<ul>
<li><strong>happens-before原则</strong>：保证有序性的规则，但是多线程并发会破坏部分规则，要采取一些措施符合这些规则来保证有序性<ul>
<li><strong>程序顺序规则</strong>：一个线程前面的代码先行发生于后面的代码</li>
<li><strong>锁规则</strong>：一个锁释放先行发生于随后的加锁</li>
<li><strong>volatile规则</strong>：一个volatile域的写先行发生于后续这个volatitle的读</li>
<li><strong>传递规则</strong>：操作A先行发生于操作B,操作B先行发生于C，则操作A先行发生与操作C</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>各种锁</strong><br>  通过锁的同步机制实现线程安全，加了锁的操作能满足原子性<ul>
<li><strong>内置锁synchronized</strong><ul>
<li>调用synchronized块和方法的对象作为内置锁</li>
<li>静态的synchronized方法以Class对象作为锁</li>
<li>获得锁和释放锁是隐式的，可重入，互斥锁</li>
</ul>
</li>
<li><strong>可重入锁ReentrantLock</strong><ul>
<li>比内置锁更加灵活，可以设置和获取锁的信息，可设置获取锁的等待时间来避免死锁</li>
<li>可以设置是否为公平锁和非公平锁，默认非公平锁；可重入，互斥锁</li>
</ul>
</li>
<li><strong>读写锁ReadWriteLock</strong><ul>
<li>ReentrantReadWriteLock是具体实现类，同时具有ReentantLock的功能</li>
<li>维护一对关联的锁，读锁是共享锁（S锁），写锁是独占锁/互斥锁（X锁</li>
</ul>
</li>
<li><strong>公平锁和非公平锁</strong><ul>
<li>公平锁是当线程取不到锁时会按先后顺序进入AQS中阻塞，当锁释放锁时，按队列的顺序取锁</li>
<li>非公平锁是有一个后来的线程刚好赶上释放锁的时机取得了锁，这对AQS里的线程是不公平的</li>
</ul>
</li>
<li><strong>自旋锁</strong><ul>
<li>当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度很快</li>
<li>但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁</li>
</ul>
</li>
<li><strong>乐观锁和悲观锁</strong><ul>
<li><strong>乐观锁</strong>总是认为资源是不存在竞争，所以没有加锁，不会有阻塞和死锁，通过CAS算法实现<ul>
<li>CAS有3个操作数，内存值V，旧的预期值A, 要修改的新值B，预期值存于线程本地内存，是从主内存拷贝的，<br>内存值在并发状态下可能被修改，内存值用了volatile保证是内存中最新的值，所以一个线程要修改共享变量<br>时总是会先检查A值是否与V值，如果不相线程就循环重新获取预期值再与内存值比较，直到操作成功，这种自<br>旋的方式速度快，但占用CPU。通过加版本号标志解决ABA问题</li>
<li>atomic包中的类大量采用了CAS算法实现变量和对象的原子性的操作</li>
</ul>
</li>
<li><strong>悲观锁</strong> 总是认为资源存在竞争，synchronized和ReetrankLock就是悲观锁</li>
</ul>
</li>
</ul>
</li>
<li><strong>ThreadLocal</strong><ul>
<li>ThreadLocal为线程提供独立的局部变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</li>
<li>ThreadLocal在类中通常定义为静态变量, 当线程为ThreadLocal实例set一个value时，发生了如下调用:当前线程<br>会把ThreadLocal实例和value存到它的ThreadLocal.ThreadLocalMap对象中，该对象由ThreadLocal实例创建并赋给<br>当前线程，实际上ThreadLocalMap是Entry&lt;ThreadLocal&lt;?&gt;, Object&gt;数组组成的结构  </li>
<li>Entry.key是ThreadLocal变量的弱引用，当ThreadLocal变量=null时，ThreadLocal对象就被回收了，<br>避免了内存泄露，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</li>
</ul>
</li>
</ul>
</li>
<li><strong>Java线程状态</strong><ul>
<li><strong>新建</strong></li>
<li><strong>可运行</strong><ul>
<li>thread.start()运行线程</li>
<li>object.notify()/notifyAll()唤醒线程，只能在同步块中调用，object必须是对象锁，否则会抛出InterruptedException</li>
<li>condition.signal()/signalAll()</li>
<li>thread.yield()</li>
</ul>
</li>
<li><strong>阻塞</strong><ul>
<li>Thread.sleep()不释放锁，让出CPU，需捕获异常</li>
</ul>
</li>
<li><strong>等待</strong><ul>
<li>thread.join()实际是用wait()实现</li>
<li>object.wait()释放锁，让出CPU, 只能在同步块中调用，object必须是对象锁，否则会抛出InterruptedException</li>
<li>condition.await()</li>
</ul>
</li>
<li><strong>计时等待</strong></li>
<li><strong>终止</strong></li>
</ul>
</li>
<li><strong>线程中断</strong><ul>
<li>运行状态的线程无法中断，中断只是改变线程中断状态的标志</li>
<li>阻塞，等待状态可被中断，中断后会抛出InterruptedException</li>
<li>I/O阻塞被中断不会退出阻塞状态，也不会抛出InterruptedException</li>
</ul>
</li>
<li><strong>并发包</strong><ul>
<li><strong>线程池</strong><br>避免频繁创建和销毁线程，可以根据需求灵活控制并发线程的数量</li>
<li><strong>Runnable和Callable</strong><br>Runable无返回值，不会抛出异常；Callable返回一个计算结果，如果无法计算会抛出异常，通常由FuntureTask封装来用</li>
<li><strong>FutureTask</strong><br>FutureTask表示异步计算的任务,同时还可以控制任务的执行，如果任务没完成get获取运算结果的操作会被阻塞,可以设置timeout属性为0通过<br>不断轮询直到取到结果而不会被阻塞  </li>
<li><strong>闭锁CountDownLatch</strong></li>
<li><strong>栅栏CyclicBarrier</strong><br>Barrier栅栏类似闭锁，某个线程运行到某个点上就等待，直到线程数够数后再重新运行，基于ReentrantLock和Condition机制实现</li>
</ul>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/10/17/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="林俊浩" />
            
              <p class="site-author-name" itemprop="name">林俊浩</p>
              <p class="site-description motion-element" itemprop="description">CS, Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-number">1.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关键字和基本概念"><span class="nav-number">2.</span> <span class="nav-text">关键字和基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据类型"><span class="nav-number">3.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">4.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见包、类、接口"><span class="nav-number">5.</span> <span class="nav-text">常见包、类、接口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">6.</span> <span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架"><span class="nav-number">7.</span> <span class="nav-text">集合框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-number">8.</span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法解惑"><span class="nav-number">9.</span> <span class="nav-text">方法解惑</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">10.</span> <span class="nav-text">多线程</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林俊浩</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '6YQaXvI0U3ywl42B0XiGS0gV-gzGzoHsz',
        appKey: 'TguUH59LxGUhuthbEUiK1Vwx',
        placeholder: '欢迎讨论',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
