<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>驿站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java总结，技术博客，日记">
<meta property="og:type" content="website">
<meta property="og:title" content="驿站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="驿站">
<meta property="og:description" content="Java总结，技术博客，日记">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="驿站">
<meta name="twitter:description" content="Java总结，技术博客，日记">
  
    <link rel="alternate" href="/atom.xml" title="驿站" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">驿站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">不积跬步，无以至千里；不积小流，无以成江海</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/18/Java基础/" class="article-date">
  <time datetime="2018-10-17T18:38:13.000Z" itemprop="datePublished">2018-10-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/18/Java基础/">Java基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>把某件东西抽象成对象，定义对象属性，定义方法等，赋予调用属性和方法的权限，其他对象只能在权限下改变获取或改变对象的状态</p>
<ul>
<li><strong>特性</strong><ul>
<li><strong>抽象</strong>：忽略细节，更注重通用的方面<ul>
<li><strong>抽象类和接口</strong><ul>
<li>抽象类可以继承实体类，前提是实体类有继承权限的构造器  </li>
<li>抽象类可以声明对象，不能实例化，可以有构造函数  </li>
<li>抽象类中可以有静态方法，接口中也可以有  </li>
<li>接口可以继承多个接口  </li>
<li>接口只能被public、abstract修饰，接口中的方法的默认public abstract修饰，JDK8以后可以用defualt修饰 </li>
<li>接口中定义的常量默认为 public static final修饰</li>
</ul>
</li>
</ul>
</li>
<li><strong>继承</strong>：子类可以使用父类的成员变量和方法，提高代码复用性<ul>
<li><strong>和组合的区别</strong><ul>
<li>继承是is - a的关系，能更好实现多态，过多使用继承代码的可维护性差</li>
<li>组合是在新类创建已有类对象复用已有类的功能，是has -a的关系，组合有更高的拓展性</li>
</ul>
</li>
</ul>
</li>
<li><strong>多态</strong>：同样的方法作用于不同对象会有不同结果<ul>
<li><strong>方法重载和方法重写</strong><ul>
<li>重载是一个编译时多态，不同的参数个数、参数类型、参数顺序</li>
<li>重写是运行时多态，调用的具体方法是动态绑定的</li>
<li>如果重载方法的参数与父类方法的参数为父子关系，优先选择子类。但不能有歧意，编译器会报错</li>
</ul>
</li>
</ul>
</li>
<li><strong>封装</strong>：对象的属性和实现方法对外隐藏，通过访问修饰符调整封装的级别</li>
</ul>
</li>
<li><strong>6原则1法则</strong><ul>
<li>单一职责原则：一个类只做它该做的事</li>
<li>开闭原则：代码易于拓展就是对拓展开发，代码不应该被修改，对修改关闭</li>
<li>依赖倒置原则：设计要依赖于抽象，面向接口编程</li>
<li>里氏替换原则：任何时候子类都可以替换掉父类</li>
<li>接口隔离原则：接口单一职责，细粒化</li>
<li>组合原则：优先使用组合复用代码</li>
<li>迪米特法则：一个对象对其他对象尽可能少的了解<h2 id="关键字和基本概念"><a href="#关键字和基本概念" class="headerlink" title="关键字和基本概念"></a>关键字和基本概念</h2></li>
</ul>
</li>
<li><strong>语法</strong><ul>
<li>continue跳出本次循环继续下次循环</li>
<li>break跳出当前循环，可跳出多重循环,跳出switch否则执行后面的case语句</li>
<li>switch表达式只能是byte, short, char, int和枚举类型，JDK7开始可以是String</li>
</ul>
</li>
<li><strong>内部类</strong>：内部类相当于外部类的一个成员变量，可以直接访问外部变量；但是外部类不能直接访问内部类变量，必须通过创建内部类实例建立联系后再访问（内外之间的访问是不关乎权限的）  <ul>
<li><strong>静态内部类</strong>：只能访问外部类的静态成员和静态方法，不依赖外部类实例而实例化</li>
<li><strong>普通内部类</strong>：能访问外部类的成员和方法，无论是否静态，但是本身不能有静态成员和静态方法，<br>  依赖外部类实例而实例化</li>
</ul>
</li>
<li><strong>构造函数</strong><ul>
<li>构造函数不能被继承和重写，可重载</li>
<li>编译器在运行子类构造函数前必须先执行父类的构造函数</li>
<li>子类构造函数中的第一行必须调用父类构造函数, 若父类只要无参构造函数，则子类构造函数可以省略这一行</li>
<li>若父类有有参的构造函数，则必须在这一行通过super显示调用父类的构造函数</li>
</ul>
</li>
<li><strong>super</strong><ul>
<li>子类重写父类方法后，通过super仍可调用父类方法</li>
</ul>
</li>
<li><strong>final</strong><ul>
<li>final变量是无法修改的，无默认值，要先赋值或者在构造方法中初始化,</li>
<li>final static表示常量，常量必须在定义时赋值</li>
<li>只有final能修饰形参，表示这个参数不能重新赋值，否则编译错误</li>
</ul>
</li>
<li><strong>静态方法和静态变量</strong><ul>
<li>类成员必须是静态的，非静态成员和非静态方法是实例成员和实例方法</li>
<li>静态方法只能访问静态变量， 普通方法既可访问静态也可访问非静态</li>
<li>静态方法是不能重写的，实际上父类和子类相同的静态方法是两个独立的方法，调用哪个方法取决于声明的类型</li>
</ul>
</li>
<li><strong>类加载顺序</strong><ul>
<li>static变量和static块的初始化顺序与代码顺序有关，哪个在前哪个先初始化</li>
<li>反编译发现构造代码块是在调用构造函数时插入到构造函数里的，位于super后(如果有)，所以是成员变量 &gt; 构造代码块 &gt; 构造函数</li>
<li>总的顺序是：父类static &gt; 子类static &gt; 父类成员 &gt; 父类构造块 &gt; 父类构造函数 &gt; 子类成员 &gt; 子类构造块 &gt; 子类构造函数<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>Java小数默认为double</li>
<li>整型根据前缀表示不同进制，16进制(0x或0X)，8进制(0),Java7开始可以写2进制(0b或0B)</li>
<li>低精度到高精度：byte&lt;short&lt;char&lt;int&lt;long&lt;float&lt;double,向下转型要强制转换，精度会损失，”+=”赋值隐含强制转换</li>
<li>char不管英文还是中文，固定占用占用2个字节，用来储存Unicode字符，所以也包括了中文；<br>C/C++中由于采用的字符编码集是ASCII，只有一个字节，因此没办法表示一个中文字符</li>
<li>不同数据类型运算时会自动向上(高精度)转型，final修饰除外</li>
<li>boolean不可以和其他基本数据类型相互转换</li>
<li>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，<br>如果其中一个操作数是float类型，另一个将会转换为float类型。否则，<br>如果其中一个操作数是long类型，另一个会转换为long类型。否则，<br>两个操作数都转换为int类型(byte，short，char进行计算时都会提升为int类型)<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2></li>
<li>&amp;有两种用法：按位与和逻辑与。无论左边运算true或false，右边也会运算，|同理</li>
<li>&amp;&amp;是短路与，左边运算结果位true,右边才会运算，||同理</li>
<li><strong>移位运算符</strong> ：按二进制形式把所有的数字移动位数，计算机使用补码表示和存储</li>
</ul>
</li>
<li><strong>&lt;&lt;</strong> : 左移，高位舍弃，低位空位补0</li>
<li><strong>&gt;&gt;</strong> : 右移，低位舍弃，高位空位补符号位（正数补0，负数补1）</li>
<li><strong>&gt;&gt;&gt;</strong> : 无符号右移，忽略符号位，空位补0<h2 id="常见包、类、接口"><a href="#常见包、类、接口" class="headerlink" title="常见包、类、接口"></a>常见包、类、接口</h2><ul>
<li><strong>包</strong>：java.lang, java.io, java.util, java.net, java.sql</li>
<li><strong>类</strong>：String, Thread, ArrayList, InputStream/OutputStream, Math</li>
<li><strong>接口</strong>：List, Map, Iterator, Runnable, Serializable<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2></li>
</ul>
</li>
</ul>
</li>
<li><strong>层次</strong>：Error和Exception继承Throwable，RuntimeException继承Exception</li>
<li><strong>类型</strong>：RuntimeException及其子类是非受检异常；除此之外Exception是受检异常</li>
<li><strong>处理</strong>：Error捕获不到，RuntimeException不要求捕获，Exception要求抛出或捕获</li>
<li><strong>常见的RuntimeException</strong>：NullPointerException, ClassCastException, IllegalArgumentExeption, IndexOutOfBoundsException</li>
<li><strong>异常语句</strong>：finally中的return语句会覆盖前面的return语句； 如果一个方法出现异常那么只运行catch和finally中的代码，其他代码忽略</li>
<li><strong>throw和throws</strong>：throw用于抛出异常，throws用于在方法中声明会出现的异常<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2></li>
<li><strong>List</strong><ul>
<li><strong>ArrayList</strong><ul>
<li>默认容量为10，默认增长0.5倍+1</li>
</ul>
</li>
<li><strong>CopyOnWriterArrayList</strong><ul>
<li>适用于读多写少的并发环境，写时对原对象拷贝进行修改操作，修改完成后再把拷贝赋给原对象</li>
<li>写的操作过于消耗资源，绝对线程安全，但是只能保证数据的最终一致性，不能保证实时一致性</li>
<li>Conllections.SynchronizedList写的性能好，读的性能差</li>
</ul>
</li>
<li><strong>LinkedList</strong><ul>
<li>任何位置都能高效插入和删除的双向链表</li>
</ul>
</li>
<li><strong>Vector</strong><ul>
<li>默认容量10，默认增长1倍，加了锁机制</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><strong>HashMap</strong><ul>
<li>JDK7：数组 + 链表实现，数组元素比作一个bucket, 每个bucket由一个Entry&lt;K,V&gt;链表组成，<br>如果K的hashcode冲突会放在相同的bucket， hash冲突严重时，链表会越来越长，时间复杂度为O(n),<br>当超过设置的装填因子会重rehash，容量扩容1倍</li>
<li>JDK8：超过装填因子时，链表转换成红黑树的结构</li>
<li>不允许键重复，对应的类要重写hashcode和equals</li>
<li>装填因子 = 元素个数 / 容量，默认容量16，装填因子大于0.75就扩容1倍</li>
<li>元素越多越容易冲突，新能降低，用拉链法解决冲突</li>
<li>支持一个null键，支持null值</li>
<li>并发环境put会出现死循环，因为扩容问题？</li>
</ul>
</li>
<li><strong>WeakHashMap</strong><ul>
<li>用于存弱引用的键值对，会被GC回收保存到ReferenceQueue，下次操作map时，同步map和queue中的对象，<br>删除被回收的键值对</li>
</ul>
</li>
<li><strong>TreeMap</strong><ul>
<li>通过键值的排序规则排序</li>
</ul>
</li>
<li><strong>LinkedHashMap</strong><ul>
<li>HashMap+LinkedList实现，用双向链表的形式把Entry&lt;K,V&gt;连接起来，保证元素的迭代顺序和跟插入顺序相同</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>加了锁机制，不可插入null键和null值，回报空指针异常(源码规定)</li>
<li>子类Properties用于读取.properties文件</li>
</ul>
</li>
<li><strong>Conllection.SynchronizedMap</strong><ul>
<li>HashTable的锁是方法级别，而它的锁是代码块级别, 可以插入null键和null值</li>
</ul>
</li>
<li><strong>ConcurrentHashMap</strong><ul>
<li>采用分段锁实现，JDK8以后采用CAS实现</li>
<li>适用于并发读写的场景，提高吞吐量，迭代时是弱一致性的</li>
</ul>
</li>
</ul>
</li>
<li><strong>Set</strong><ul>
<li><strong>HashSet</strong><ul>
<li>是HashMap的keySet，基本和Map类似</li>
</ul>
</li>
<li><strong>TreeSet</strong><ul>
<li>与TreeMap类似</li>
</ul>
</li>
</ul>
</li>
<li><strong>错误检测机制</strong><ul>
<li><strong>fail-fast</strong>: 迭代器有个变量expectedModCount保存着集合的modCount变量值，<br>modCount值记录着集合的修改次数，每次next和remove都会检查这两个值是否相等，<br>如果不相等则抛出ConcurrentModifiedException,java.util包下的集合类都是快速失败的  </li>
<li><strong>fail-safe</strong>: 迭代器对集合的拷贝进行遍历，集合被修改对遍历无影响，java.util.concurrent包下<br>的集合都是安全失败的</li>
</ul>
</li>
<li><strong>Iterator</strong><ul>
<li>支持从集合中安全删除对象，在迭代时只能针对迭代器操作，如果在迭代时直接对集合修改，<br>会抛出ConcurrentModifiedException</li>
<li>foreach语句内部使用Iterator实现</li>
</ul>
</li>
<li><strong>集合数组转换</strong><ul>
<li>集合转数组 toArray(T[] a)</li>
<li>数组转集合 Arrays.asList() 实质上仍是数组，只是通过适配实现转换，不能用操作集合的方法对转换后的集合操作<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2>运行状态下能获取类的信息，能调用任意对象的方法和属性，但破坏了封装程序；更加灵活，但性能低</li>
</ul>
</li>
<li><strong>得到Class对象的方式</strong>：object.getClass(), object.class, Class.forName(String classname)</li>
<li><strong>Class.forName()和ClassLoader.loadClass()</strong><br>Class.forName()内部实际调用的方法是Class.forName(className,true,classloader),true表示加载class文件到JVM并初始化类；ClassLoader.loadClass(className)方法内部实际调用的方法是ClassLoader.loadClass(className,false)，false表示不链接,意味着不会进行类初始化  <h2 id="方法解惑"><a href="#方法解惑" class="headerlink" title="方法解惑"></a>方法解惑</h2></li>
<li><strong>数组拷贝效率</strong>： System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环拷贝</li>
<li><strong>hashCode()</strong> ：默认返回对象的内存地址</li>
<li><strong>equals()</strong> ：在Object中是比较对象内存地址的，相当于”=”,在String中被重写了，比较的是字符串值</li>
<li><strong>Integer.valueOf()和new Integer()</strong> ：Integer.valueOf会先查看缓存是否有实例，如果在-128 ~ 127范围内没找到缓存中的实例，则创建实例，<br>  new Integer()则直接创建实例</li>
<li><strong>Math.round()/floor()/ceil()</strong> ：注意float型是转成int型，double型转成long型<ul>
<li><strong>round</strong> : 加上0.5向下取整</li>
<li><strong>floor</strong> ：向下取整，取数轴上比参数小的整数</li>
<li><strong>ceil</strong> : 向上取整，取数轴上比参数大的整数 <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2>线程是运行在一个单一进程上下文中的逻辑流，通俗点讲就是：线程是进程内部的执行序列</li>
</ul>
</li>
<li><strong>并发和并行</strong><br>并发是一个时刻多个任务的运行，宏观并行，微观串行；并行是同个时间上多个任务的运行，通常需要多核CPU才能实现</li>
<li><strong>线程安全</strong><br>通过分析并发下是否满足三大性质能实现线程安全<ul>
<li><strong>Java内存模型(JMM)</strong><br>分为主内存和工作内存。主内存存储共享的变量；每个线程都有自己的工作内存，存储线程本地变量和需要共享变量<br>变量的拷贝副本，每次修改拷贝时都会更新主内存的值</li>
<li><strong>volatile</strong><ul>
<li>volatile关键字保证变量被修改后，变量的值对其他线程是立即可见的（新的变量值立马写会主内存，保证可见性）  </li>
<li>对于变量非原子性的操作（例如：变量自增）是不能保证原子性的</li>
<li>volatile能只能限制变量前后之间代码的重排序，但不能保证volatile之前和之后代码的重排序，能保证一定的有序性</li>
</ul>
</li>
<li><strong>三大性质</strong><ul>
<li><strong>原子性</strong><ul>
<li><strong>竞态条件</strong>：多个线程同时竞争/更新共享的资源是会产生竞态条件，通过同步保证原子性</li>
<li><strong>临界区</strong>：导致竞态条件的代码区</li>
<li><strong>复合操作</strong>: 一组以原子性的操作确保线程安全，如自增就是非原子性操作，但是用atomic变量自增就可满足原子性操作</li>
</ul>
</li>
<li><strong>可见性</strong><br>执行读操作的线程能立马看到其他线程写入的值</li>
<li><strong>有序性</strong><br>Java内存模型运行编译器和处理器对指令重排序，对单线程无影响，但会影响多线程并发执行的正确性<ul>
<li><strong>happens-before原则</strong>：保证有序性的规则，但是多线程并发会破坏部分规则，要采取一些措施符合这些规则来保证有序性<ul>
<li><strong>程序顺序规则</strong>：一个线程前面的代码先行发生于后面的代码</li>
<li><strong>锁规则</strong>：一个锁释放先行发生于随后的加锁</li>
<li><strong>volatile规则</strong>：一个volatile域的写先行发生于后续这个volatitle的读</li>
<li><strong>传递规则</strong>：操作A先行发生于操作B,操作B先行发生于C，则操作A先行发生与操作C</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>各种锁</strong><br>  通过锁的同步机制实现线程安全，加了锁的操作能满足原子性<ul>
<li><strong>内置锁synchronized</strong><ul>
<li>调用synchronized块和方法的对象作为内置锁</li>
<li>静态的synchronized方法以Class对象作为锁</li>
<li>获得锁和释放锁是隐式的，可重入，互斥锁</li>
</ul>
</li>
<li><strong>可重入锁ReentrantLock</strong><ul>
<li>比内置锁更加灵活，可以设置和获取锁的信息，可设置获取锁的等待时间来避免死锁</li>
<li>可以设置是否为公平锁和非公平锁，默认非公平锁；可重入，互斥锁</li>
</ul>
</li>
<li><strong>读写锁ReadWriteLock</strong><ul>
<li>ReentrantReadWriteLock是具体实现类，同时具有ReentantLock的功能</li>
<li>维护一对关联的锁，读锁是共享锁（S锁），写锁是独占锁/互斥锁（X锁</li>
</ul>
</li>
<li><strong>公平锁和非公平锁</strong><ul>
<li>公平锁是当线程取不到锁时会按先后顺序进入AQS中阻塞，当锁释放锁时，按队列的顺序取锁</li>
<li>非公平锁是有一个后来的线程刚好赶上释放锁的时机取得了锁，这对AQS里的线程是不公平的</li>
</ul>
</li>
<li><strong>自旋锁</strong><ul>
<li>当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度很快</li>
<li>但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁</li>
</ul>
</li>
<li><strong>乐观锁和悲观锁</strong><ul>
<li><strong>乐观锁</strong>总是认为资源是不存在竞争，所以没有加锁，不会有阻塞和死锁，通过CAS算法实现<ul>
<li>CAS有3个操作数，内存值V，旧的预期值A, 要修改的新值B，预期值存于线程本地内存，是从主内存拷贝的，<br>内存值在并发状态下可能被修改，内存值用了volatile保证是内存中最新的值，所以一个线程要修改共享变量<br>时总是会先检查A值是否与V值，如果不相线程就循环重新获取预期值再与内存值比较，直到操作成功，这种自<br>旋的方式速度快，但占用CPU。通过加版本号标志解决ABA问题</li>
<li>atomic包中的类大量采用了CAS算法实现变量和对象的原子性的操作</li>
</ul>
</li>
<li><strong>悲观锁</strong> 总是认为资源存在竞争，synchronized和ReetrankLock就是悲观锁</li>
</ul>
</li>
</ul>
</li>
<li><strong>ThreadLocal</strong><ul>
<li>ThreadLocal为线程提供独立的局部变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本</li>
<li>ThreadLocal在类中通常定义为静态变量, 当线程为ThreadLocal实例set一个value时，发生了如下调用:当前线程<br>会把ThreadLocal实例和value存到它的ThreadLocal.ThreadLocalMap对象中，该对象由ThreadLocal实例创建并赋给<br>当前线程，实际上ThreadLocalMap是Entry&lt;ThreadLocal&lt;?&gt;, Object&gt;数组组成的结构  </li>
<li>Entry.key是ThreadLocal变量的弱引用，当ThreadLocal变量=null时，ThreadLocal对象就被回收了，<br>避免了内存泄露，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除</li>
</ul>
</li>
</ul>
</li>
<li><strong>Java线程状态</strong><ul>
<li><strong>新建</strong></li>
<li><strong>可运行</strong><ul>
<li>thread.start()运行线程</li>
<li>object.notify()/notifyAll()唤醒线程，只能在同步块中调用，object必须是对象锁，否则会抛出InterruptedException</li>
<li>condition.signal()/signalAll()</li>
<li>thread.yield()</li>
</ul>
</li>
<li><strong>阻塞</strong><ul>
<li>Thread.sleep()不释放锁，让出CPU，需捕获异常</li>
</ul>
</li>
<li><strong>等待</strong><ul>
<li>thread.join()实际是用wait()实现</li>
<li>object.wait()释放锁，让出CPU, 只能在同步块中调用，object必须是对象锁，否则会抛出InterruptedException</li>
<li>condition.await()</li>
</ul>
</li>
<li><strong>计时等待</strong></li>
<li><strong>终止</strong></li>
</ul>
</li>
<li><strong>线程中断</strong><ul>
<li>运行状态的线程无法中断，中断只是改变线程中断状态的标志</li>
<li>阻塞，等待状态可被中断，中断后会抛出InterruptedException</li>
<li>I/O阻塞被中断不会退出阻塞状态，也不会抛出InterruptedException</li>
</ul>
</li>
<li><strong>并发包</strong><ul>
<li><strong>线程池</strong><br>避免频繁创建和销毁线程，可以根据需求灵活控制并发线程的数量</li>
<li><strong>Runnable和Callable</strong><br>Runable无返回值，不会抛出异常；Callable返回一个计算结果，如果无法计算会抛出异常，通常由FuntureTask封装来用</li>
<li><strong>FutureTask</strong><br>FutureTask表示异步计算的任务,同时还可以控制任务的执行，如果任务没完成get获取运算结果的操作会被阻塞,可以设置timeout属性为0通过<br>不断轮询直到取到结果而不会被阻塞  </li>
<li><strong>闭锁CountDownLatch</strong></li>
<li><strong>栅栏CyclicBarrier</strong><br>Barrier栅栏类似闭锁，某个线程运行到某个点上就等待，直到线程数够数后再重新运行，基于ReentrantLock和Condition机制实现</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/18/Java基础/" data-id="cjndi8iz20001qcj37s2oqo4c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/17/hello-world/" class="article-date">
  <time datetime="2018-10-17T12:41:48.861Z" itemprop="datePublished">2018-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/17/hello-world/" data-id="cjndi8iz20000qcj3mxzd9li8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/10/18/Java基础/">Java基础</a>
          </li>
        
          <li>
            <a href="/2018/10/17/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 林俊浩<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>