<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="CS, Java">
<meta property="og:type" content="website">
<meta property="og:title" content="驿站">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="驿站">
<meta property="og:description" content="CS, Java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="驿站">
<meta name="twitter:description" content="CS, Java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>驿站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6f502c419cf100aac28bd9cae568a13c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">驿站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">不积跬步，无以至千里；不积小流，无以成江海</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/21/数据结构与算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林俊浩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驿站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/21/数据结构与算法/" itemprop="url">数据结构与算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-21T16:37:05+08:00">
                2018-10-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/21/数据结构与算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/21/数据结构与算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表是最基本，最简单的数据结构。有2种存储结构，<strong>顺序存储</strong>和<strong>链式存储</strong>。数组就是一种线性表，数组的特点是静态分配存储单元，在内存是连续存储的，随机存取数据简单，索引O(1),最后位置插入删除O(1),其他位置插入删除要移动数据元素O(n)。<strong>链式存储</strong>是由<strong>数据域</strong>和<strong>指针域</strong>构成的结点组成，分为<strong>单向链表</strong>和<strong>双向链表</strong>，索引O(n);单向链表的get,set,insert,remove等操作要从<strong>头结点</strong>开始遍历操作结点的前驱对其指针域进行操作O(n),双向链表的结点保存着前驱结点的指针和后继结点的指针，不用从头结点开始遍历，插入删除O(1)</p>
<hr>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种运算受限的线性表，只能在栈顶进行插入删除等操作O(1)。特点是<strong>后进先出</strong>，有<strong>顺序栈</strong>和<strong>链式栈</strong>。栈常<strong>应用</strong>在深度遍历算法，非递归方式实现递归算法，后缀表达式的计算等</p>
<hr>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列是另一种运算受限的线性表，队头下标是<strong>front</strong>，队尾下标是<strong>rear</strong>，它只能在front进行删除操作（出队），在rear进行插入操作（入队），特点是<strong>先进先出FIFO</strong>。有<strong>顺序队列</strong>和<strong>循环队列</strong>，当由数组实现顺序队列时，入队时rear++，出队时front++，当入队元素个数超过数组容量时下标越界，但是数组前面部分在出队后是空的，这种情况称为<strong>假溢出</strong>；循环队列逻辑上首尾是相连的，目的是为了节省空间，判断<strong>队列为空的条件是front==rear</strong>，<strong>队列满条件是front=(front+1)%length</strong>,+1是为了给队列留一个空位，如果不留的话队列满与队列为空条件是相同的，不能够判断。主要应用在<strong>先来先服务</strong>问题中，广度遍历算法</p>
<hr>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是应用最多的一种数据结构，是由n&gt;=0个结点构成的，结点由<strong>left指针，数据域，right指针</strong>构成，顺序存储结构比较适合完全二叉树，一般的二叉树会造成空间浪费，链式存储最适合实现二叉树  </p>
<ul>
<li><strong>性质</strong><ul>
<li>第i层(i&gt;=1)最大结点数是2<sup>i-1</sup></li>
<li>深度为k(k&gt;=1)，最大结点总数是2<sup>k</sup>-1</li>
<li>叶结点个数=度为2的结点个数+1，即n<sub>0</sub>=n<sub>2</sub>+1</li>
<li>最大深度为[long<sub>2</sub>n]+1</li>
</ul>
</li>
<li><strong>遍历</strong><ul>
<li>先序，中序，后序均可以用递归实现或者堆栈实现递归的效果</li>
<li>层次可用队列实现。从根节点开始入队，循环“结点出队，访问结点，其左右儿子结点入队”</li>
</ul>
</li>
</ul>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>从上到下左到右排序的编号与<strong>满二叉树</strong>中的编号一一对应,非根结点（序号i&gt;1）的父结点序号是i/2,结点i的左孩子结点是2i(2i&lt;=n，否则无左孩子)，右孩子结点是2i+1(2i+1&lt;=n，否则无右孩子)</p>
<h3 id="二叉查找树-搜索树-排序树"><a href="#二叉查找树-搜索树-排序树" class="headerlink" title="二叉查找树/搜索树/排序树"></a>二叉查找树/搜索树/排序树</h3><p>当不为空树时，左子树的所有结点值小于它根结点的值，右子树的所有结点值大于它的根结点的值，并且左右子树都是二叉排序树，所以最小值在树的最左端，最大值在树的最右端</p>
<ul>
<li><strong>查找</strong><ul>
<li>若x小于根结点值，在左子树继续查找；若x大于根结点的值，在右子树继续查找；若x等于结点的值则查找完成并返回该结点的值</li>
<li>查找的最坏情况是单支树，像单链表一样，按顺序查找（n+1）/2，即O(n)；最好情况是完全二叉树或满二叉树O(log<sub>2</sub>n)</li>
</ul>
</li>
</ul>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>不为空树时，左右子树的高度差绝对值不超过1，在二叉搜索树中，如果删除一个有左右子结点的结点，需要此结点的后继来代替删除的结点，多次操作后，这课树会向左偏沉，时间复杂度会趋向于O(n),这时平衡二叉搜索树就该登场了，常用的实现有<strong>红黑树</strong>，<strong>AVL</strong>,<strong>Treap</strong>等等，查找，插入，删除的时间复杂度都是O(log<sub>2</sub>n)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/20/数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林俊浩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驿站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/20/数据库/" itemprop="url">数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-20T22:28:22+08:00">
                2018-10-20
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/20/数据库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/20/数据库/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p><strong>1NF</strong>字段不可再分；<strong>2NF</strong>满足1NF情况下非主属性完全依赖于主属性,消除部分依赖，也就是说如果有两个主属性，那么非主属性不能只依赖于其中一个主属性；<strong>3NF</strong>满足2NF情况下消除传递依赖,也就是说在一张表中通过主属性A能得到B或者C，但是C也能从B得到，这时候要拆分表消除传递依赖。不管如何，现实情况下如果满足严格的范式，虽然能减少数据冗余，但是实体之间的关系会变得非常复杂</p>
<hr>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务有点像若干个有序的小任务组成的大任务。有ACID四大特性。要么全完成，要么全不完成（<strong>原子性</strong>）；事务完成后，数据库的数据符合预期保持正确完整（<strong>一致性</strong>）；并发的事务交叉读写数据导致数据不一致，所以要采取隔离手段防止这种现象（<strong>隔离性</strong>）；事务完成后，所有的变化都会持久化到数据库，也就是写到硬盘上（<strong>持久性</strong>）。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>在实际开发中，由于数据库服务器是处于高并发环境下的，所以要选择合适的隔离级别保护数据的一致性，同时提高服务器的性能。</p>
<p><img src="/images/隔离级别.jpg" style="width:400px !important; height:250px !important"></p>
<p><strong>赃读</strong>指在一个事务中读取到其他事务未提交的数据；<strong>不可重复度</strong>指在一个事务中多次查询的数据不同（被其他事务update）;<strong>幻读</strong>指在一个事务中多次查询的结果集多了或者少了（被其他事务delete,insert）。在MySQL的InnoDB引擎在RR级别使用了MVCC（多版本并发控制）避免幻读，将行锁与行的多个版本结合起来，用更小的开销提高并发性能。<strong>序列化</strong>用的是独占锁，性能极差。</p>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程是完成特定功能的SQL语句集，能在存储过程中调用其他存储过程，但不能drop其他存储过程。其入参不能于数据表字段名相同，例如在删除记录时，指定的入参实际会变成每条记录的字段值，导致把表的数据全部删除。</p>
<h3 id="与函数的区别"><a href="#与函数的区别" class="headerlink" title="与函数的区别"></a>与函数的区别</h3><p>存储过程一般作为独立的部分执行，而函数可以嵌入select语句调用</p>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是特殊的存储过程，只是在insert,update,delete发生时才执行，是隐式调用的。相同的表，相同的事件只能创建一个触发器，当触发器不用时要及时删除</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图依据基本表存在，是预编译的SQL语句，不占物理空间，可理解为虚拟表。与临时表不同，临时表会占用物理空间，暂时还没用在实际项目中。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是以数据结构组织的，存储了记录的指针。不同的索引，数据结构有所不同，数据的读写效率也不一样。<strong>聚集索引</strong>表中数据的逻辑顺序与键值顺序相同，有主键索引，其数据结构是B树，一种平衡树，有利于查找。<strong>非聚集索引</strong>有唯一索引和普通索引，普通索引有单列索引和多列索引，多列索引要注意<strong>最左前缀</strong>的问题。索引长度越长区分度越高内存消耗越大效率越高。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>char类型的值存储时会填充空格到指定长度，检索时删除空格，速度快但是浪费空间，适合在InnoDB和MyISAM用</li>
<li>datatime的范围是1000-9999；timestamp的范围是1970-2038而且会把时区转化为UTC（世界标准时间）进行存储，查询时又转化成当前时区返回，因此timestamp适用于跨时区的需求  </li>
<li>blob类型用于存储二进制形式的文本  </li>
</ul>
<h2 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h2><ul>
<li>允许null值的列不能作为唯一标识</li>
<li>使用默认值而不是null更好，因为有默认值不会因为null而出现NPE</li>
<li>外连接可以查询到关联或未关联的行的值，未关联的行中列显示为null</li>
<li>外键和级联是强阻塞的，不适合分布式、高并发的环境</li>
<li>外键不用用在不同引擎的表，不能跨引擎  </li>
</ul>
<h2 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h2><ul>
<li>distinct用于select语句中去重，位于select语句第一个字段前，当有多个字段时，只有这几个字段都相同才会合并；也可用于聚集函数如count(distinct column)</li>
<li>count(column)不会统计为值null的行，而count(*)会</li>
<li>desc 表名 和show columns from 表名 的效果一样都是查看表结构</li>
<li>insert语句中指出字段名比不指出更安全，不指出的话值与字段名的顺序不容易对应</li>
<li>truncate 表名 与不带where子句的delete效果一样，truncate不可以rollback，所以速度快，delete可以rollback; drop 表名是连表都删除了，不可rollback  </li>
</ul>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>数据库有许多方面都可以优化，需要结合实际与经验不断优化数据库服务器的性能</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul>
<li>同表操作中，自连接比子查询效率高</li>
<li>在select的where子句中，判断某个字段时如果用到下面关键字或符号会使该列的索引失效（is null, &lt;&gt;2, in(1, 2), or)  </li>
</ul>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><h3 id="分离活跃数据"><a href="#分离活跃数据" class="headerlink" title="分离活跃数据"></a>分离活跃数据</h3><p>把活跃数据存在默认表优先查询，不活跃数据定期转移到备用表</p>
<h3 id="批量读取和延迟修改"><a href="#批量读取和延迟修改" class="headerlink" title="批量读取和延迟修改"></a>批量读取和延迟修改</h3><h3 id="主从复制和读写分离"><a href="#主从复制和读写分离" class="headerlink" title="主从复制和读写分离"></a>主从复制和读写分离</h3><p>对数据库集群，主数据库服务器处理写的操作，多台从服务器处理读操作。从服务器复制主服务器的数据实现同步</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/18/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林俊浩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驿站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/18/Java基础/" itemprop="url">Java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-18T02:38:13+08:00">
                2018-10-18
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/18/Java基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/18/Java基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>把某件东西抽象成对象，定义对象属性，定义方法等，赋予调用属性和方法的权限，其他对象只能在权限下改变获取或改变对象的状态</p>
<ul>
<li><strong>特性</strong><ul>
<li><strong>抽象</strong>：忽略细节，更注重通用的方面<ul>
<li><strong>抽象类和接口</strong><ul>
<li>抽象类可以继承实体类，前提是实体类有继承权限的构造器  </li>
<li>抽象类可以声明对象，不能实例化，可以有构造函数  </li>
<li>抽象类中可以有静态方法，接口中也可以有  </li>
<li>接口可以继承多个接口  </li>
<li>接口只能被public、abstract修饰，接口中的方法的默认public abstract修饰，JDK8以后可以用defualt修饰 </li>
<li>接口中定义的常量默认为 public static final修饰</li>
</ul>
</li>
</ul>
</li>
<li><strong>继承</strong>：子类可以使用父类的成员变量和方法，提高代码复用性<ul>
<li><strong>和组合的区别</strong><ul>
<li>继承是is - a的关系，能更好实现多态，过多使用继承代码的可维护性差</li>
<li>组合是在新类创建已有类对象复用已有类的功能，是has -a的关系，组合有更高的拓展性</li>
</ul>
</li>
</ul>
</li>
<li><strong>多态</strong>：同样的方法作用于不同对象会有不同结果<ul>
<li><strong>方法重载和方法重写</strong><ul>
<li>重载是一个编译时多态，不同的参数个数、参数类型、参数顺序</li>
<li>重写是运行时多态，调用的具体方法是动态绑定的</li>
<li>如果重载方法的参数与父类方法的参数为父子关系，优先选择子类。但不能有歧意，编译器会报错</li>
</ul>
</li>
</ul>
</li>
<li><strong>封装</strong>：对象的属性和实现方法对外隐藏，通过访问修饰符调整封装的级别</li>
</ul>
</li>
<li><strong>6原则1法则</strong><ul>
<li>单一职责原则：一个类只做它该做的事</li>
<li>开闭原则：代码易于拓展就是对拓展开发，代码不应该被修改，对修改关闭</li>
<li>依赖倒置原则：设计要依赖于抽象，面向接口编程</li>
<li>里氏替换原则：任何时候子类都可以替换掉父类</li>
<li>接口隔离原则：接口单一职责，细粒化</li>
<li>组合原则：优先使用组合复用代码</li>
<li>迪米特法则：一个对象对其他对象尽可能少的了解</li>
</ul>
</li>
</ul>
<h2 id="关键字和基本概念"><a href="#关键字和基本概念" class="headerlink" title="关键字和基本概念"></a>关键字和基本概念</h2><ul>
<li><strong>语法</strong><ul>
<li>continue跳出本次循环继续下次循环</li>
<li>break跳出当前循环，可跳出多重循环,跳出switch否则执行后面的case语句</li>
<li>switch表达式只能是byte, short, char, int和枚举类型，JDK7开始可以是String</li>
</ul>
</li>
<li><strong>内部类</strong>：内部类相当于外部类的一个成员变量，可以直接访问外部变量；但是外部类不能直接访问内部类变量，必须通过创建内部类实例建立联系后再访问（内外之间的访问是不关乎权限的）  <ul>
<li><strong>静态内部类</strong>：只能访问外部类的静态成员和静态方法，不依赖外部类实例而实例化</li>
<li><strong>普通内部类</strong>：能访问外部类的成员和方法，无论是否静态，但是本身不能有静态成员和静态方法，依赖外部类实例而实例化</li>
</ul>
</li>
<li><strong>构造函数</strong><ul>
<li>构造函数不能被继承和重写，可重载</li>
<li>编译器在运行子类构造函数前必须先执行父类的构造函数</li>
<li>子类构造函数中的第一行必须调用父类构造函数, 若父类只要无参构造函数，则子类构造函数可以省略这一行</li>
<li>若父类有有参的构造函数，则必须在这一行通过super显示调用父类的构造函数</li>
</ul>
</li>
<li><strong>super</strong><ul>
<li>子类重写父类方法后，通过super仍可调用父类方法</li>
</ul>
</li>
<li><strong>final</strong><ul>
<li>final变量是无法修改的，无默认值，要先赋值或者在构造方法中初始化,</li>
<li>final static表示常量，常量必须在定义时赋值</li>
<li>只有final能修饰形参，表示这个参数不能重新赋值，否则编译错误</li>
</ul>
</li>
<li><strong>静态方法和静态变量</strong><ul>
<li>类成员必须是静态的，非静态成员和非静态方法是实例成员和实例方法</li>
<li>静态方法只能访问静态变量， 普通方法既可访问静态也可访问非静态</li>
<li>静态方法是不能重写的，实际上父类和子类相同的静态方法是两个独立的方法，调用哪个方法取决于声明的类型</li>
</ul>
</li>
<li><strong>类加载顺序</strong><ul>
<li>static变量和static块的初始化顺序与代码顺序有关，哪个在前哪个先初始化</li>
<li>反编译发现构造代码块是在调用构造函数时插入到构造函数里的，位于super后(如果有)，所以是成员变量 &gt; 构造代码块 &gt; 构造函数</li>
<li>总的顺序是：父类static &gt; 子类static &gt; 父类成员 &gt; 父类构造块 &gt; 父类构造函数 &gt; 子类成员 &gt; 子类构造块 &gt; 子类构造函数</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>Java小数默认为double</li>
<li>整型根据前缀表示不同进制，16进制(0x或0X)，8进制(0),Java7开始可以写2进制(0b或0B)</li>
<li>低精度到高精度：byte&lt;short&lt;char&lt;int&lt;long&lt;float&lt;double,向下转型要强制转换，精度会损失，”+=”赋值隐含强制转换</li>
<li>char不管英文还是中文，固定占用占用2个字节，用来储存Unicode字符，所以也包括了中文；C/C++中由于采用的字符编码集是ASCII，只有一个字节，因此没办法表示一个中文字符</li>
<li>不同数据类型运算时会自动向上(高精度)转型，final修饰除外</li>
<li>boolean不可以和其他基本数据类型相互转换</li>
<li>如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。否则，如果其中一个操作数是float类型，另一个将会转换为float类型。否则，如果其中一个操作数是long类型，另一个会转换为long类型。否则，两个操作数都转换为int类型(byte，short，char进行计算时都会提升为int类型)</li>
</ul>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul>
<li>&amp;有两种用法：按位与和逻辑与。无论左边运算true或false，右边也会运算，|同理</li>
<li>&amp;&amp;是短路与，左边运算结果位true,右边才会运算，||同理</li>
<li><strong>移位运算符</strong> ：按二进制形式把所有的数字移动位数，计算机使用补码表示和存储<ul>
<li><strong>&lt;&lt;</strong> : 左移，高位舍弃，低位空位补0</li>
<li><strong>&gt;&gt;</strong> : 右移，低位舍弃，高位空位补符号位（正数补0，负数补1）</li>
<li><strong>&gt;&gt;&gt;</strong> : 无符号右移，忽略符号位，空位补0</li>
</ul>
</li>
</ul>
<h2 id="常见包、类、接口"><a href="#常见包、类、接口" class="headerlink" title="常见包、类、接口"></a>常见包、类、接口</h2><ul>
<li><strong>包</strong>：java.lang, java.io, java.util, java.net, java.sql</li>
<li><strong>类</strong>：String, Thread, ArrayList, InputStream/OutputStream, Math</li>
<li><strong>接口</strong>：List, Map, Iterator, Runnable, Serializable</li>
</ul>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul>
<li><strong>层次</strong>：Error和Exception继承Throwable，RuntimeException继承Exception</li>
<li><strong>类型</strong>：RuntimeException及其子类是非受检异常；除此之外Exception是受检异常</li>
<li><strong>处理</strong>：Error捕获不到，RuntimeException不要求捕获，Exception要求抛出或捕获</li>
<li><strong>常见的RuntimeException</strong>：NullPointerException, ClassCastException, IllegalArgumentExeption, IndexOutOfBoundsException</li>
<li><strong>异常语句</strong>：finally中的return语句会覆盖前面的return语句； 如果一个方法出现异常那么只运行catch和finally中的代码，其他代码忽略</li>
<li><strong>throw和throws</strong>：throw用于抛出异常，throws用于在方法中声明会出现的异常</li>
</ul>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><ul>
<li><strong>List</strong><ul>
<li><strong>ArrayList</strong><ul>
<li>默认容量为10，默认增长0.5倍+1</li>
</ul>
</li>
<li><strong>CopyOnWriterArrayList</strong><ul>
<li>适用于读多写少的并发环境，写时对原对象拷贝进行修改操作，修改完成后再把拷贝赋给原对象</li>
<li>写的操作过于消耗资源，绝对线程安全，但是只能保证数据的最终一致性，不能保证实时一致性</li>
<li>Conllections.SynchronizedList写的性能好，读的性能差</li>
</ul>
</li>
<li><strong>LinkedList</strong><ul>
<li>任何位置都能高效插入和删除的双向链表</li>
</ul>
</li>
<li><strong>Vector</strong><ul>
<li>默认容量10，默认增长1倍，加了锁机制</li>
</ul>
</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><strong>HashMap</strong><ul>
<li>JDK7：数组 + 链表实现，数组元素比作一个bucket, 每个bucket由一个Entry&lt;K,V&gt;链表组成，如果K的hashcode冲突会放在相同的bucket， hash冲突严重时，链表会越来越长，时间复杂度为O(n),当超过设置的装填因子会重rehash，容量扩容1倍</li>
<li>JDK8：超过装填因子时，链表转换成红黑树的结构</li>
<li>不允许键重复，对应的类要重写hashcode和equals</li>
<li>装填因子 = 元素个数 / 容量，默认容量16，装填因子大于0.75就扩容1倍</li>
<li>元素越多越容易冲突，新能降低，用拉链法解决冲突</li>
<li>支持一个null键，支持null值</li>
<li>并发环境put会出现死循环，因为扩容问题？</li>
</ul>
</li>
<li><strong>WeakHashMap</strong><ul>
<li>用于存弱引用的键值对，会被GC回收保存到ReferenceQueue，下次操作map时，同步map和queue中的对象，<br>删除被回收的键值对</li>
</ul>
</li>
<li><strong>TreeMap</strong><ul>
<li>通过键值的排序规则排序</li>
</ul>
</li>
<li><strong>LinkedHashMap</strong><ul>
<li>HashMap+LinkedList实现，用双向链表的形式把Entry&lt;K,V&gt;连接起来，保证元素的迭代顺序和跟插入顺序相同</li>
</ul>
</li>
<li><strong>HashTable</strong><ul>
<li>加了锁机制，不可插入null键和null值，回报空指针异常(源码规定)</li>
<li>子类Properties用于读取.properties文件</li>
</ul>
</li>
<li><strong>Conllection.SynchronizedMap</strong><ul>
<li>HashTable的锁是方法级别，而它的锁是代码块级别, 可以插入null键和null值</li>
</ul>
</li>
<li><strong>ConcurrentHashMap</strong><ul>
<li>采用分段锁实现，JDK8以后采用CAS实现</li>
<li>适用于并发读写的场景，提高吞吐量，迭代时是弱一致性的</li>
</ul>
</li>
</ul>
</li>
<li><strong>Set</strong><ul>
<li><strong>HashSet</strong><ul>
<li>是HashMap的keySet，基本和Map类似</li>
</ul>
</li>
<li><strong>TreeSet</strong><ul>
<li>与TreeMap类似</li>
</ul>
</li>
</ul>
</li>
<li><strong>错误检测机制</strong><ul>
<li><strong>fail-fast</strong>: 迭代器有个变量expectedModCount保存着集合的modCount变量值，<br>modCount值记录着集合的修改次数，每次next和remove都会检查这两个值是否相等，<br>如果不相等则抛出ConcurrentModifiedException,java.util包下的集合类都是快速失败的  </li>
<li><strong>fail-safe</strong>: 迭代器对集合的拷贝进行遍历，集合被修改对遍历无影响，java.util.concurrent包下<br>的集合都是安全失败的</li>
</ul>
</li>
<li><strong>Iterator</strong><ul>
<li>支持从集合中安全删除对象，在迭代时只能针对迭代器操作，如果在迭代时直接对集合修改，<br>会抛出ConcurrentModifiedException</li>
<li>foreach语句内部使用Iterator实现</li>
</ul>
</li>
<li><strong>集合数组转换</strong><ul>
<li>集合转数组 toArray(T[] a)</li>
<li>数组转集合 Arrays.asList() 实质上仍是数组，只是通过适配实现转换，不能用操作集合的方法对转换后的集合操作</li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>运行状态下能获取类的信息，能调用任意对象的方法和属性，但破坏了封装程序；更加灵活，但性能低</p>
<ul>
<li><strong>得到Class对象的方式</strong>：object.getClass(), object.class, Class.forName(String classname)</li>
<li><strong>Class.forName()和ClassLoader.loadClass()</strong><br>Class.forName()内部实际调用的方法是Class.forName(className,true,classloader),true表示加载class文件到JVM并初始化类；ClassLoader.loadClass(className)方法内部实际调用的方法是ClassLoader.loadClass(className,false)，false表示不链接,意味着不会进行类初始化  </li>
</ul>
<h2 id="方法解惑"><a href="#方法解惑" class="headerlink" title="方法解惑"></a>方法解惑</h2><ul>
<li><strong>数组拷贝效率</strong>： System.arraycopy &gt; clone &gt; Arrays.copyOf &gt; for循环拷贝</li>
<li><strong>hashCode()</strong> ：默认返回对象的内存地址</li>
<li><strong>equals()</strong> ：在Object中是比较对象内存地址的，相当于”=”,在String中被重写了，比较的是字符串值</li>
<li><strong>Integer.valueOf()和new Integer()</strong> ：Integer.valueOf会先查看缓存是否有实例，如果在-128 ~ 127范围内没找到缓存中的实例，则创建实例，<br>  new Integer()则直接创建实例</li>
<li><strong>Math.round()/floor()/ceil()</strong> ：注意float型是转成int型，double型转成long型<ul>
<li><strong>round</strong> : 加上0.5向下取整</li>
<li><strong>floor</strong> ：向下取整，取数轴上比参数小的整数</li>
<li><strong>ceil</strong> : 向上取整，取数轴上比参数大的整数 </li>
</ul>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程是运行在一个单一进程上下文中的逻辑流，通俗点讲就是：线程是进程内部的执行序列</p>
<ul>
<li><strong>并发和并行</strong></li>
</ul>
<p>并发是一个时刻多个任务的运行，宏观并行，微观串行；并行是同个时间上多个任务的运行，通常需要多核CPU才能实现</p>
<ul>
<li><strong>线程安全</strong></li>
</ul>
<p>通过分析并发下是否满足三大性质能实现线程安全</p>
<pre><code>- **Java内存模型(JMM)**

分为主内存和工作内存。主内存存储共享的变量；每个线程都有自己的工作内存，存储线程本地变量和需要共享变量  
变量的拷贝副本，每次修改拷贝时都会更新主内存的值

- **volatile**
    - volatile关键字保证变量被修改后，变量的值对其他线程是立即可见的（新的变量值立马写会主内存，保证可见性）  
    - 对于变量非原子性的操作（例如：变量自增）是不能保证原子性的
    - volatile能只能限制变量前后之间代码的重排序，但不能保证volatile之前和之后代码的重排序，能保证一定的有序性
- **三大性质**
    - **原子性**
        - **竞态条件**：多个线程同时竞争/更新共享的资源是会产生竞态条件，通过同步保证原子性
        - **临界区**：导致竞态条件的代码区
        - **复合操作**: 一组以原子性的操作确保线程安全，如自增就是非原子性操作，但是用atomic变量自增就可满足原子性操作
    - **可见性**
    执行读操作的线程能立马看到其他线程写入的值
    - **有序性**
    Java内存模型运行编译器和处理器对指令重排序，对单线程无影响，但会影响多线程并发执行的正确性
        - **happens-before原则**：保证有序性的规则，但是多线程并发会破坏部分规则，要采取一些措施符合这些规则来保证有序性
            - **程序顺序规则**：一个线程前面的代码先行发生于后面的代码
            - **锁规则**：一个锁释放先行发生于随后的加锁
            - **volatile规则**：一个volatile域的写先行发生于后续这个volatitle的读
            - **传递规则**：操作A先行发生于操作B,操作B先行发生于C，则操作A先行发生与操作C
- **各种锁**
    通过锁的同步机制实现线程安全，加了锁的操作能满足原子性
    - **内置锁synchronized**
        - 调用synchronized块和方法的对象作为内置锁
        - 静态的synchronized方法以Class对象作为锁
        - 获得锁和释放锁是隐式的，可重入，互斥锁
    - **可重入锁ReentrantLock**
        - 比内置锁更加灵活，可以设置和获取锁的信息，可设置获取锁的等待时间来避免死锁
        - 可以设置是否为公平锁和非公平锁，默认非公平锁；可重入，互斥锁
    - **读写锁ReadWriteLock**
        - ReentrantReadWriteLock是具体实现类，同时具有ReentantLock的功能
        - 维护一对关联的锁，读锁是共享锁（S锁），写锁是独占锁/互斥锁（X锁
    - **公平锁和非公平锁**
        - 公平锁是当线程取不到锁时会按先后顺序进入AQS中阻塞，当锁释放锁时，按队列的顺序取锁
        - 非公平锁是有一个后来的线程刚好赶上释放锁的时机取得了锁，这对AQS里的线程是不公平的
    - **自旋锁**
        - 当前线程不停地执行循环体，不进行线程状态的改变，所以响应速度很快
        - 但当线程数不停增加时，性能下降明显，因为每个线程都需要执行，占用CPU时间。如果线程竞争不激烈，并且保持锁的时间段。适合使用自旋锁
    - **乐观锁和悲观锁**
        - **乐观锁**总是认为资源是不存在竞争，所以没有加锁，不会有阻塞和死锁，通过CAS算法实现
            - CAS有3个操作数，内存值V，旧的预期值A, 要修改的新值B，预期值存于线程本地内存，是从主内存拷贝的，  
            内存值在并发状态下可能被修改，内存值用了volatile保证是内存中最新的值，所以一个线程要修改共享变量  
            时总是会先检查A值是否与V值，如果不相线程就循环重新获取预期值再与内存值比较，直到操作成功，这种自  
            旋的方式速度快，但占用CPU。通过加版本号标志解决ABA问题
            - atomic包中的类大量采用了CAS算法实现变量和对象的原子性的操作
        - **悲观锁** 总是认为资源存在竞争，synchronized和ReetrankLock就是悲观锁
- **ThreadLocal**
    - ThreadLocal为线程提供独立的局部变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本
    - ThreadLocal在类中通常定义为静态变量, 当线程为ThreadLocal实例set一个value时，发生了如下调用:当前线程  
    会把ThreadLocal实例和value存到它的ThreadLocal.ThreadLocalMap对象中，该对象由ThreadLocal实例创建并赋给  
    当前线程，实际上ThreadLocalMap是Entry&lt;ThreadLocal&lt;?&gt;, Object&gt;数组组成的结构  
    - Entry.key是ThreadLocal变量的弱引用，当ThreadLocal变量=null时，ThreadLocal对象就被回收了，  
    避免了内存泄露，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除
</code></pre><ul>
<li><strong>Java线程状态</strong><ul>
<li><strong>新建</strong></li>
<li><strong>可运行</strong><ul>
<li>thread.start()运行线程</li>
<li>object.notify()/notifyAll()唤醒线程，只能在同步块中调用，object必须是对象锁，否则会抛出InterruptedException</li>
<li>condition.signal()/signalAll()</li>
<li>thread.yield()</li>
</ul>
</li>
<li><strong>阻塞</strong><ul>
<li>Thread.sleep()不释放锁，让出CPU，需捕获异常</li>
</ul>
</li>
<li><strong>等待</strong><ul>
<li>thread.join()实际是用wait()实现</li>
<li>object.wait()释放锁，让出CPU, 只能在同步块中调用，object必须是对象锁，否则会抛出InterruptedException</li>
<li>condition.await()</li>
</ul>
</li>
<li><strong>计时等待</strong></li>
<li><strong>终止</strong></li>
</ul>
</li>
<li><strong>线程中断</strong><ul>
<li>运行状态的线程无法中断，中断只是改变线程中断状态的标志</li>
<li>阻塞，等待状态可被中断，中断后会抛出InterruptedException</li>
<li>I/O阻塞被中断不会退出阻塞状态，也不会抛出InterruptedException</li>
</ul>
</li>
<li><strong>并发包</strong><ul>
<li><strong>线程池</strong><br>避免频繁创建和销毁线程，可以根据需求灵活控制并发线程的数量</li>
<li><strong>Runnable和Callable</strong><br>Runable无返回值，不会抛出异常；Callable返回一个计算结果，如果无法计算会抛出异常，通常由FuntureTask封装来用</li>
<li><strong>FutureTask</strong><br>FutureTask表示异步计算的任务,同时还可以控制任务的执行，如果任务没完成get获取运算结果的操作会被阻塞,可以设置timeout属性为0通过<br>不断轮询直到取到结果而不会被阻塞  </li>
<li><strong>闭锁CountDownLatch</strong></li>
<li><strong>栅栏CyclicBarrier</strong><br>Barrier栅栏类似闭锁，某个线程运行到某个点上就等待，直到线程数够数后再重新运行，基于ReentrantLock和Condition机制实现</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/17/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="林俊浩">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="驿站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/17/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-17T20:41:48+08:00">
                2018-10-17
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/10/17/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/10/17/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="林俊浩" />
            
              <p class="site-author-name" itemprop="name">林俊浩</p>
              <p class="site-description motion-element" itemprop="description">CS, Java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">林俊浩</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '6YQaXvI0U3ywl42B0XiGS0gV-gzGzoHsz',
        appKey: 'TguUH59LxGUhuthbEUiK1Vwx',
        placeholder: '欢迎讨论',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
